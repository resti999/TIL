# 자바 스레드2부 1강-스레드 동기화란? 그리고 동기화의 필요성
* 스레드는 Heap(new 로생성되는 객체가 할당되는 동적 영역), Data영역(전역변수가 저장되는 영역)은 공유하지만 Stack영역(지역 변수가 저장되는 영역)은 각자 이용한다.
* 한 전역변수를 여러 스레드가 나눠서 처리하게 되면 많은 문제가 발생. 동시성의 문제 ->동기화로 처리해야 한다.
* 동기화 -  줄 세우는 것

# 자바 스레드2부 2강- monitor lock을 이용한 동기화
* 임계영역(critical section) : 다른 스레드가 끼어들지 말아야하는 영역(Ex. gIndex를 증가에서 출력까지의 영역)은 동시에 실행되어서는 안됨. 화장실에 비유할 수 있다.
* 잠금장치(monitor lock) : 임계영역을 침버하지 못하도록 잠그는 개체(다른 스레드들은 waiting상태가 된다.)- 아무 자료형이나 상관없다. 참조형이라면
```
package part2;

public class Ex2Program_monitor_critical_section {

	public static void main(String[] args) {
		
		Runnable subMain = new Runnable() {//쓰레드용 인터페이스 runnable을 부모로 갖는 익명 클래스의 객체 생성
			@Override
			public void run() {
				print();
			}
		};
		
		
		
		Thread th1 = new Thread( subMain);
		th1.setName("sub1");//스레드 이름 설정
		Thread th2 = new Thread(subMain);
		th2.setName("sub2");
		Thread th3 = new Thread(subMain);
		th3.setName("sub3");
		
		
		th1.start();//스레드 시작하기
		th2.start();
		th3.start();
		
		Thread th = Thread.currentThread();//main thread 불러오는것
		th.setName("Main"); //
//		print();
		
		try {
			Thread.sleep(2000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		if(th1.isAlive())
			th1.interrupt();
		
		System.out.println("===Exit===");
	}
	
	static Object lockIndex = new Object(); // 잠금장치로 사용하게 될 객체, 아무 의미도 없고 그저 객체면 된다.
	static int gIndex =0; // 데이터/정적영역 - 모든 스레드가 공유
	
	private static void print() {
		
		int index =0; //스택에 공간 마련 - 스레드별로 마련
		
		Thread th = Thread.currentThread();// thread정보 불러오기
		
		for(int i=0;i<100;i++) {
			
			
			
			try {
				Thread.sleep(20);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
			// lock으로 잠금을 해야 하는 상황
			synchronized (lockIndex) {//synchoronized키워드를 통해 잠금장치로 쓰고 싶은 객체를 넣는다. -> 이 코드에 먼저 도착한 스레드가 저 객체를 사용하게 되면 synchronized키워드 안의 코드가 실행되는 동안 다른 스레드들은 waiting상태가 된다.
				
				index++;
				gIndex++;
				
				System.out.printf("%s[%d] : %d, index:%d, gIndex:%d\n", th.getName(), th.getId(), i+1, index, gIndex);
			}
			
		}
	}


}
```
* 동기화를 하지 않는다면 전역변수 gIndex에 접근할 때 두번 증가시키거나 증가를 안시키거나 하는 충돌이 일어날 수 있는데 동기화를 한다면 gIndex가 정상적으로 300이 출력된다.

# 자바 스레드2부 3강- 메소드 단위의 동기화
* 메서드 반환형 앞에 synchronized 붙이면 메서드 전체가 동기화된다.
* 메인 클래스
```
package part2;

public class Ex3Program_method_syn {

	public static void main(String[] args) {
		
		CharList list = new CharList();
		
		Runnable subMain = new Runnable() {//쓰레드용 인터페이스 runnable을 부모로 갖는 익명 클래스의 객체 생성
			@Override
			public void run() {
				for(int i=0;i<80;i++)
					list.printNext();
			}
		};
		
		
		
		Thread th1 = new Thread( subMain);
		th1.setName("sub1");//스레드 이름 설정
		Thread th2 = new Thread(subMain);
		th2.setName("sub2");
		Thread th3 = new Thread(subMain);
		th3.setName("sub3");
		
		
		th1.start();//스레드 시작하기
		th2.start();
		th3.start();
		
		Thread th = Thread.currentThread();//main thread 불러오는것
		th.setName("Main"); //
		
		
		System.out.println("===Exit===");
	}


}
```
* CharList클래스 , 동기화한 메서드를 가짐
```
package part2;

public class CharList {
	private char[] list;
	private int index;
	
	public CharList() {
		list = new char[240];
		for(int i=0; i<240; i++)
			list[i] = (char)i;
		index = 0;
	}

	public synchronized void printNext() {// 메서드 전체 동기화.
		Thread th = Thread.currentThread();
		
		char ch = list[index];
		
		try {
			Thread.sleep(20);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		
		System.out.printf("%s[%d] : index:%d, char:%c\n", th.getName(), th.getId(), index, list[index]);
		index++;
	}
	
	
}
```

# 자바 스레드2부4강- 메소드 동기화의 문제점
