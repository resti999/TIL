# 자바 객체지향 강의 1강 - 객체지향 프로그래밍의 시작 캡슐화
* 캡슐화 : 데이터 구조와 그것을 사용하는 함수들을 하나의 영역에 함께 정의하는 것
* 함수가 많아지면 기능에 따라서 분류할 것인가 데이터에 따라서 분류할 것인가? 데이터에 따라서 분류해야한다. 왜?-> 함수는 외부의 수정에 절대 영향을 받아서는 안되는데 함수를 데이터에 따라 분류하는 것이 데이터 구조화된 데이터를 사용하는 함수 모듈의 독립성을 침해하는 문제를 해결 할 수 있기 때문에
* 구조화된 데이터를 매개변수로 쓰게 된다면 참조형식으로 데이터를 받기 때문에 구조화된 데이터(class)의 변수명이 바뀌거나 한다면 함수의 독립성이 침해됨 - 구조화된 객체를 사용하는 함수는 객체의 구조 변경에 아주 취약하다.
* 해결법 : 구조화된 객체를 사용하는 함수를 한 곳에 모아둬야 유지보수가 편함. (구조가 변경되면 코드 수정이 불가피하기 때문)
* 캡슐화를 해야 데이터 구조에 따른 코드의 수정범위를 캡슐 범위로 한정할 수 있다.

# 자바 객체지향 강의 2강 - 함수들을 캡슐화하기
* 데이터 구조를 사용하는 함수는 모두 같은 클래스에 넣어야 한다.(캡슐화)
* 데이터 구조를 변경했을 때 오류 범위(수정해야 할 코드)가 한 클래스(한 파일?) 안으로 한정됨
* 캡슐이 깨졌다 : 데이터 구조가 변경됐을 때(클래스의 변수명이 바뀌거나 변수가 추가되거나 했을 경우) 외부 클래스에서 오류(수정필요)가 발생하면 캡슐이 깨졌다고한다.
* 해결방법 : 객체를 은닉화 할 수 있는 방법들이 있음

# 자바 객체지향 강의 3강 - 인스턴스(Instance) 메소드
* 함수가 주체가 아닌 객체를 중심으로 함수를 호출하는 방식이 객체지향
```
void main()
{
  ExamList list = new ExamList();
  ExamList.inputList(list);
  ExamList.printList(list);
  ExamList.saveList(list);
}
```
↓(객체지향으로 변경)
```
void main()
{
  ExamList list = new ExamList();
  list.inputList();   //list(야) 입력(해)
  list.printList();   
  list.saveList();
}
```
* 인스턴스 : 객체를 소프트웨어에 실체화 한 것
* 인스턴스 함수(사실은 메서드) : 객체를 통해서 호출되고 묵시적으로 **객체(데이터구조)를 무조건 넘겨받는 함수(메서드)**
* 인스턴스 함수가 기본
* 객체지향은 의인화와 비슷?
* 객체지향(OOP: Object Oriented Programming) : 객체에 일을 시키는 형태의 프로그래밍

# 자바 객체지향 강의 4강 - 인스턴스(Instance) 메소드 구현하기
* 기존의 함수의 인스턴스 전달: ExamList.inputList(list); -> 새로운 함수의 인스턴스 전달 : list.inputList();
* static method(고전적인 함수) vs instance method(반드시 객체를 통해서 호출되는 함수, 묵시적으로 그 객체를 넘겨받음)
* this 키워드 : 자기 자신(객체,instance)을 나타내는 키워드
* this 키워드는 안쓸 수 있으면 안 쓰는게 좋다.

# 자바 객체지향 강의 5강 - 캡슐의 은닉성과 접근 지정자
* 캡슐 : 데이터 구조와 그 데이터 구조를 이용하는 함수를 묶어놓은 집합체
* 캡슐화의 장점 :  데이터 구조를 변경했을 때 오류의 범위가 캡슐 안으로 한정된다.
* 접근 제어 지시자 :  캡슐을 깨지 못하게 하는 도구, 객체를 통한 함수의 호출로 다른 클래스를 이용해야 한다.

|접근지시자|동일 클래스|파생 클래스|외부 클래스|
|---|---|---|---|
|private|O|X|X|
|protected|O|O|X|
|public|O|O|O|

* 데이터구조(인스턴스 변수)는 보통 private으로 하고 서비스하는 함수들은 public으로 한다.

# 자바 객체지향 강의 6강 - 생성자(Constructor)
* new ExamList(); - >실체화(메인 메모리에 변수들 공간 확보됨) 후 초기화(생성자실행)
* 생성자의 조건 : 객체가 생성되자 마자 무조건 제일 먼저 실행되어야 만 한다. 생성될 때 단 한번만 실행되어야 만 한다.
* 생성자는 이름이 없기 때문에 명시적으로 호출 불가.
* new ExamList(ExamList실체화)+()(객체의 생성자를 호출해달라, 이름 없음);
* 생성자 형식 :  함수 형식에서 반환값 없는 형태,  함수명은 class 이름(엄밀히 함수 이름은 아님 한정사로 보는게 맞음)
* 인스턴스 변수는 초기값이 있다.

# 자바 객체지향 강의 7강 - 생성자 오버로드(Constructor Overload)
* 기본 생성자를 안만들고 오버로드 생성자만 만든다면? 기본 생성자 호출 불가 ->오버로드 할거면 구현해야함
* 호출을 통해 코드 집중화를 해야한다. 보통 함수와 동일하게
```
pubcli ExamList(){
  this(3); //<- 생성자는 생성된 객체를 통해서만 호출할 수 있기 때문에 이런 형식
}

public ExamList(int size){
  exams = new Exam[size];
  current = 0;
}
```
* 생성자를 하나도 정의하지 않는다면? -> 기본 생성자 저절로 만들어짐(컴파일러가) /하나도 없을 경우만 자동으로 만들어줌

# 자바 객체지향 강의 8강 - Getters와 Setters 그리고 이것을 써야하는 이유
* 클래스의 캡슐화가 깨졌는지 보는 법 : 클래스의 데이터 구조(변수)에 수정을 한 후 다른 클래스에서 오류가 나는지 확인.
* 다른 클래스의 데이터를 사용해야 할 경우 : 함수를 통해서 호출 -> 그래서 Getter Setter 필요
* 데이터 구조가 변경된다는 것은? : 변수를 추가하고 분류하는 것들

# 자바 객체지향 강의 9강 - Exam 클래스의 캡슐화 완성
* eclipse get/setter만들기 : 마우스 오른쪽 클릭 ->source 클릭 -> generate Getter/Setter 클릭
* 오버로드 생성자를 만들면 컴파일러가 기본 생성자를 자동으로 만들어주지 않기 때문에 기본 생성자도 구현해줘야한다.

# 자바 객체지향 강의 10강 - UI 코드는 분리하는 것이 기본(?)
* 캡슐이나 메서드 안에서 앞으로 변화가 이루어질 부분은 분리하는 것이 좋다.
* 입/출력은 사용자와 상호작용하는 부분, 따로 분리하는게 좋다 왜? 입력과 출력은 플롯폼에 따라 변하기 때문에!\
* 한 함수에 기능이 2개이상 담겨있으면 분리하는게 좋다

# 자바 객체지향 강의 11강 - ExamConsole 클래스 구현하기(?)

# 자바 객체지향 강의 12강 - Has A 상속(?)
* 캡슐(class)들은 서로를 사용하거나 사용되는 관계를 가지고 있다. 
* 일반적으로 List들은 어떠한 객체를 갖고 있긴 하지만 사용하진 않는다.
* 실질적으로 사용하는 객체의 관계와 구성하고 있는 객체의 관계가 일치하지 않게되는 경우 생김 
* 표현 할 때는 사용관계와 구성관계가 일치할 수 있도록 표현.
* *Has A 관계 : 하나의 객체를 부품으로 갖고 기능을 구현할 때 그 객체의 함수들을 사용*
   * Composition Has A : 생성 될 때 객체를 가짐, 일체형 
   * Aggregation Has A : 생설 될 때는 없어도 필요할 때 마다 객체를 가짐
 * dependency : 객체를 사용하는 관계? 한 객체가 만들어지기 위해서 꼭 필요한 객체관계 , 구성하는 관계까지 갖는 객체라면 Has a 관계
 * *원래 class 안쪽에 영역에서 연산자 사용 불가(함수 안에서만 사용 가능)* 그래서 원래 멤버변수로서 private ExamList list = new ExamList();라는 구문은 맞지 않지만 컴파일러가 알아서 아래와 같이 변경함
```
private ExamList list;
public ExamConsole(){
  list = new ExamList();
}
```
* ExamList와 Exam관계는 Aggregation has a 관계.  처음 생성될 때 exam객체가 생성되진 않기 때문(보통 클래스 배열을 가질 때 이런 관계를 가지는 것 같음)

# 자바 객체지향 강의 13강 - 코드 재사용이란?
* 재사용이라고 하는것은 소스 코드가 아닌 컴파일된 배포코드를 재사용하는 것이다
* 코드 배포 방법
   1. 컴파일 - >Exam.class
	 2. 압축 - >Exam.zip
	 3. jar ->Exam.jar
* eclipse 배포 기능 : 프로젝트 우클릭 ->Export ->java->jar->원하는 소스코드파일 선택->경로 선택 ->Finish
* 도스에서 배포된 파일 사용하는 방법 : javac -cp"jar파일경로" 배포된파일 사용하고 싶은 java파일명
* eclipse에서 배포된 파일 사용하는 방법 : 배포된파일 사용하고 싶은 프로젝트 우클릭 ->Build Path->Configure Build Path->Librarie 탭-> Add External JARs...->사용할 jar파일 경로선택->apply and close->Explorer에 Referenced Libraries확인->사용할 java파일에서 import하기

# 자바 객체지향 강의 14강 - IS A 상속이란?
* 객체지향 3대 덕목 : 1. 캡슐화 2. 상속 3. 다형성
* 보통 상속을 말하면 IS A 상속을 말한다.
* IS A 상속을 할 수 있으면 하는게 제일 좋음
* IS A 상속은 Frame Work이다?

# 자바 객체지향 강의 15강 - Exam을 IS A 상속하기
* child(=하위,파생)일수록 더 구체적 parent(=상위,기반) 일수록 더 보편적
* 상속 키워드 extends, class 선언부 끝에 적음

# 자바 객체지향 강의 16강 - Override(우선순위가 높은) 메소드
* 자식 클래스의 생성자는 부모 클래스의 생성자를 호출하는 super();가 자동으로 생성됨.(무조건 생성)
* 부모 객체 가리키는 키워드 : super, 객체 자신 가리키는 키워드 : this
* Override(가리다,재정의) : 상속 받은 클래스의 함수를 덮어쓰는것. 먼저 자기 객체에 있는 함수인지 찾아보고 없으면 부모 객체에서 찾아봄
* eclipse에서 쉽게 override하는법 : 자식 클래스에서 Ctrl+space누르면 override가능한 method들이 보임
* override한 함수 위에 @Override라는 annotation 적어줘야함

# 자바 객체지향 강의 17강 - 자식 클래스의 객체 초기화
* 생성자를 호출할 땐 갓 생성된 객체여야 한다.
* 부모객체는 부모의 기능으로 초기화 한 후 자식객체의 변수 초기화
```
public NewlecExam(){
	this.NewlecExam(0,0,0,0);
}

public NewlecExam(int kor, int eng, int math, int com){
	super(kor, eng, math);
	this.com=com;
}
```

# 자바 객체지향 강의 18강 - 참조형식과 호출되는 메소드의 관계
* 부모자식 관계는 참조변수와 생성된 객체가 다를 수 있다. 부모클래스 변수명 = new 자식클래스();  - 가능
* 참조변수인걸 생각못하고 부모클래스가 작은 그릇이라 안될거라 생각하는 경우 많지만 참조변수라 왼쪽에 부모클래스가 와야함. ->참조할것이 생성되는 관계만 가능
* 자바는 참조변수의 함수보다 생성된객체의 함수 호출을 우선으로 한다.(*단, 참조 형식이 갖고 있는 method에 한해서!(override된 함수만)* .Exam클래스에 total method가 구현이 안돼 있다면 오류가 난다.)
```
Exam exam = new NewlecExam(1,1,1,1);
exam.total(); // 이 경우 NewlecExam의 total method를 호출한다.
```
* Exam 클래스에만 total함수가 있다면 그 함수가 호출
