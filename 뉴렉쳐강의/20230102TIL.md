# 자바 구조적인 프로그래밍 강의 3강 - 코드 구조화 Bottom Up 방식 연습 #2
* eclipse에서 호출된 함수 선언,정의부로 가려면 호출된 함수 ctrl+왼쪽클릭하거나 클릭 후 F3키 누르기, 다시 돌아가려면 선언, 정의부에서 함수명 클릭한 후 Alt+왼쪽방향키 누르기
* 메인 함수에 큰 흐름 - 함수에 작은 흐름으로 계층형 구조

# 자바 구조적인 프로그래밍 강의 4강 - 매개변수를 이용한 함수 고립화
* 전역변수를 함수 안에서 사용했을 때 전역변수 이름에 변화가 생기면 함수 안의 내용도 영향을 미침
* 해결 방법 :매개변수를 통해 함수내부에서 참조, 전역 변수를 사용하는 것은 이름이 충돌나고 오류가 날 확률이 높으므로 메인 함수에 변수를 선언하고 함수에는 매개변수로 전달하는 방법을 사용
* 배열 연산은 최소화 하는게 좋다.

# 자바 구조적인 프로그래밍 강의 5강 - 함수 이름 짓기
* 함수 명명법 : 기능+재료(ex genLotto)
* 카멜표기법 사용

# 자바 구조적인 프로그래밍 강의 6강 - Top Down 방식으로 구현하는 간단 예제
* 함수 이름 지을 때 create/generate 차이 : create는 공간까지 만듦, generate는 값만 만듦
* 탑 다운 방식을 할 때 큰 흐름으로서 함수 이름 부터 선언 후 구체적인 기능(함수 정의)은 나중에 구현한다

# 자바 구조적인 프로그래밍 강의 7강 - 함수의 매개변수
* 구조적 프로그래밍 = 함수로 코드를 나누는 것, 함수를 통해 구조가 생긴다.

# 자바 구조적인 프로그래밍 강의 8강 - 데이터 구조화
* 구조화 = 그룹핑 
* 데이터를 개념적으로 학생, 교육등 개념 단위의 데이터를 데이터 구조화라고 한다. 개념화된 데이터=Entity
* 자바에서는 원의 지름, x축,y축 등을 하나로 묶은 것을 클래스를 통해 원이라는 데이터 단위로 나타낼 수 있다. (entity)
* c언어에서는 structure라는 구조체 문법으로 entity를 생성
* 기본 자료형 변수가 아닌 모든 변수는 참조변수
* new 키워드를 통해 개체(class)를 실존하는 객체로 만듦 이것을 참조변수에 담고 사용.

# 자바 구조적인 프로그래밍 강의 9강 - 구조체를 이용한 코드 작성하기
* 참조변수 : 생성된 객체를 식별하는 이름 생성된 객체의 주소값을 지님.
* 반복해서 .연산자나 배열을 사용하게 될 경우 임시변수를 적극 활용하자
* 데이터 구조화(entity생성) ->구조화된 데이터 실체화-> 이용  의 순서

# 자바 구조적인 프로그래밍 강의 10강 - 구조체 배열 이용하기
* 클래스는 함수를 포함해 캡슐 용도로 활용.   entity는 데이터를 구조화하는 구조체로서의 역할만
* Exam exam = new Exam();      에서 new Exam();은 객체를 만든것
* Exam[] exams = new Exam[3];      에서 new Exam[3]; 은 참조변수 공간 3개를 만든것, 객체는 따로 만들어야함
* 클래스 배열은 객체 배열이 아니라 객체 참초배열이다.
* for문에서 변수의 선언은 연산이 아니기 때문에 반복 할 때마다 선언되는 것이 아니라 비효율적지 않다.

# 자바 구조적인 프로그래밍 강의 11강 - 가변 길이 배열
* 배열은 무조건 고정길이
* 함수 매개변수로 기본자료형을 선언하고 인자를 넘기면 값이 복사돼 함수 안에서 밖에서 받은 변수의 값을 조작하지 못한다. c언어에서는 포인터를 통해 주소를 넘겨받을 수 있었지만 자바에서는 불가능

# 자바 구조적인 프로그래밍 강의 12강 - 가변 길이를 위한 구조체 생성
* 함수 단위에서 공유해야 할 데이터라면 큰 단위의 구조체(entity)로 묶어서 공유.

# 자바 구조적인 프로그래밍 강의 13강 - 가변 길이 배열 구현하기
* 가변길이 배열을 위한 구조체의 변수 3가지 : ([]+current+capacity)+amount
* 공간이 모자랄 경우 : if(capacity == current)
* 배열 늘리는 순서
   1. amount개 확장한 새로운 배열 temp를 생성
   2. list에 있는 데이터를 temp 배열로 옮긴다.
   3. temp가 참조하는 객체를 list가 참조하게 한다.
   4. 현재 capacity의 값을 +10 증가시킨다.
```
if(capacity == current)
{
   Exam[] temp = new Exam[capacity+amount];
   for(int i=0;i<current;i++)
      temp[i] = list[i];
   list = temp;
   capacity += amount;
}
```  
* 객체를 참조하고 있는 변수가 사라지면 그 객체는 garbage가 돼서 jre의 garbage collector가 수거해감

# 자바 구조적인 프로그래밍 강의 14강 - 함수 오버로딩(overloading)
* 함수 오버로딩 : 같은 기능 하지만 다른 인자를 가지는 함수를 추가하는것 - 함수 이름이 같음, 매개변수가 다름
* 함수 오버로딩을 하는 이유 : 보통 매개변수가 많은 함수 하나로 운용이 가능하지만 매개변수 많은 함수를 사용할 빈도가 낮을 경우 매개변수가 많은 함수로만 운영하는건 비효율적. 구현할 때도 매개변수 많은 함수를 정의하고 나머지 함수들은 그 함수를 재호출하면 되기 때문에 구현에 있어서도 크게 번거롭지 않기 때문
* 매개변수가 제일 적은 함수가 주 함수가 그것을 기준으로 매개변수가 늘어나는 함수가 오버로드 함수이다.(구현은 반대)
* 오버로드를 할 경우 반드시 집중화 해야함.( 오버로드 함수 안에서 재호출을 통해 코드를 편집할 때 한 곳에서만 가능하게!), 인자가 적은 쪽에서 많은 쪽의 함수를 재호출

# 자바 구조적인 프로그래밍 강의 15강 - 코드 실행과 함수 호출 스택
* 코드 실행과 메모리 사용관계
   * Data : 코드가 실행되는 과정에서 데이터가 있으면 그 데이터를 보관하는 영역
      * Heap(입석) : 동적으로 생성되는 메모리를 관리하는 공간
      * Stack(예약석) : 지역변수를 관리하는 공간
   * Text : 메모리에 코드가 올라오는 영역
* 프로그램이 실행될 때 항상 main함수가 먼저 실행. 함수가 실행되기 전에 연산이 실행되기 위한 변수공간을 미리 마련함(Stack에)
* 메모리에 올라간 프로그램을 Process라고 함
* new 연산자는 동적으로 heap에 할당
* 함수 호출 단계를 따라서 쌓이듯이 변수가 할당된다 해서 stack 마지막에 호출된 함수의 변수들이 가장먼저 메모리에서 제거되고 제일 먼저 호출된 함수의 변수들은 가장 나중에 제거됨
* Stack영역이 사라져도 Heap의 데이터는 그대로 남아있음. jre의 Garbage Collector가 참조가 끝난 heap 제거
  

